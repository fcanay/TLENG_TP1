\subsection{Decisiones de diseño}
Implementamos el \emph{AFD} como una clase con la siguiente estructura:

\begin{itemize}
	\item estados: Una lista de enteros para representar a los estados del \emph{AFD}
	\item estado\_inicial: Representa al estado inicial del \emph{AFD}
	\item estados\_finales: Una lista de enteros para representar a los estados finales del \emph{AFD}
	\item delta: Es un diccionario que dice para cada estado, que tranciciones puede tomar y hacia que estado va al tomar dichas transiciones. El diccionario tiene estados como claves y para cada estado tiene una lista de pares $<char, estado>$ como significado.
	\item alfabeto: Una lista de caracteres que representa los distintos elementos del lenguaje del \emph{AFD}
\end{itemize}

Para mayor comodidad, decidimos definir el invariante de clase que los estados se representan con números enteros del 1 a N, donde N = longitud(estados).

Por otro lado, tomamos como transición $\lambda$ a las transiciones que tienen el caracter vacío.

Decidimos que tanto el algoritmo de completar como el de minimizar no puede asumir que el AFD de entrada es completo, por lo que lo completan.

\subsection{Algoritmos Utilizados}

Los algoritmos utilizados en el trabajo práctico son la implementación de los que vimos en clase, tanto en la práctica como en la teórica.

Para los algoritmos \emph{Minimizar} y \emph{Determinizar} utilizamos los algoritmos vistos en la clase práctica.

Para transformar de una expresión regular a un \emph{AFD}. Basamos el algoritmo en la construcción utilizada en la demostración del siguiente teorema:


\subsection{Problemas encontrados}

Durante la implementación del método \emph{toDOT} nos encontramos con el problema de cómo imprimir $\lambda$, los caracteres espacio, tab y $\backslash$. Decidimos imprimirlos como \emph{lambda}, \emph{espacio},  \emph{$\backslash$t} y $\backslash$, respectivamente.

Cabe aclarar que, por ejemplo para imprimir $\backslash$ vía DOT tenemos que imprimir $\backslash\backslash$. Para esto, tenemos que escapar ambas $\backslash$, por lo que en nuestro archivo .py se lee $\backslash\backslash\backslash\backslash$

Cuando comenzamos a 



